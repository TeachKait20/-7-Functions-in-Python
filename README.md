# -7-Functions-in-Python
## Функции в Python

<img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/work.gif?raw=true">

Помимо встроенных функций в Python, можно создать и свою собственную. Функции позволяют объединять блоки кода, которые выполняют определенные задачи, и использовать их многократно в разных частях программы. В таком случае ключевое слово `def` используется для определения функции. <br> <br>
Функция в Python — это самостоятельный блок кода, который выполняет определенную задачу. <br> <br>
Синтаксис:  <br>
```
def имя_функции(параметры):
    """Документация (опционально)"""
    # Тело функции
    # Инструкции
    return результат
```
Компоненты определения функции: <br>
* `def`- Ключевое слово, используемое для объявления новой функции.
* `имя_функции`- Имя функции, которое используется для ее вызова. Должно следовать правилам именования переменных.
* `параметры` или `аргументы`- Переменные, которые функция принимает в качестве входных данных. Указываются в скобках. Если параметров нет, скобки остаются пустыми.
* `Документация (опционально)`- Строка, заключенная в тройные кавычки, описывающая, что делает функция. Она может отстутствовать.
* `Тело функции`- Блок кода, который выполняется при вызове функции. Он должен быть сдвинут вправо (используя отступы).
* `return`- Оператор, используемый для возврата значения из функции. Если `return` не указан, функция вернет `None`. `return` - сохраняет результат функции, его можно заменить на `print`, но тогда функция будет только выводить результат на экран без сохранения.

## Примеры функций
### Пример 1

Программа, которая выводит сумму двух чисел:
```python
def add(a, b):
    """Возвращает сумму двух чисел."""
    result  = a + b
    return result 

# Вызов функции (несколько вариантов)
print(add.__doc__) # Вызов документации функции
var_summ = add(3, 5) # Передаём значения другой переменной
print(var_summ)  # Выведет: 8
print(add(10, 5)) # Напрямую вызываем функцию. Выведет: 15
```
Обратите внимание, что вызов функции происходит по её имени и без ключевого слова `def`

### Пример 2

Рассмотрим ситуацию: есть компьютерная игра с различными персонажами и диалогами. 

| Персонаж | Фраза |
|----------|----------|
| <img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/magician.jpg?raw=true" width="125">   | **Mage:** I use my best spell for protection.|
| <img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/archer.jpg?raw=true" width="125">   | **Archer:** My people are ready! What's next?|
| <img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/enemy.jpg?raw=true" width="125">   | **Enemy:** AAAAaaarrrrrggghhhhh|

Таких диалогов (строк) может быть огромное количество. Наша задача: проверить у всех ли строк в конце есть знак препинания и не является ли строка пустой. <br>
Для начала представим всё в виде кода:
```python
Mage = "I use my best spell for protection."
Archer = "My people are ready! What's next?"
Enemy = "AAAAaaarrrrrggghhhhh"
```
Данное задание можно сделать с помощью простейших условий и применить их к каждой строке:
```python
if len(Mage) == 0:
    print("Строка пуста!")
else:
    if Mage[-1] in "!.?":
        print(True)
    else:
        print(False)

if len(Archer) == 0:
    print("Строка пуста!")
else:
    if Archer[-1] in "!.?":
        print(True)
    else:
        print(False)

if len(Enemy) == 0:
    print("Строка пуста!")
else:
    if Enemy[-1] in "!.?":
        print(True)
    else:
        print(False)
```
Но таких строк может быть гораздо больше, а код сложнее. Чтобы оптимизировать процесс, создадим функцию:
```python
# Функция для проверки строки
def exam_string(string):
    # Проверка, пуста ли строка
    if len(string) == 0:
        print("Строка пуста!")
        return None  # Возвращаем None, так как строка пуста
    else:
        # Проверка, оканчивается ли строка на любой из символов '!', '.', '?'
        if string[-1] in "!.?":
            return True
        else:
            return False

# Вызов функции для каждой строки и вывод результатов
print(exam_string(Mage))   # Ожидается: True
print(exam_string(Archer)) # Ожидается: True
print(exam_string(Enemy))  # Ожидается: False
```
Так код станет короче и проще читаемый. Данную функцию можно будет вызвать в любое время одной строкой и проверить код.

### Пример 3

Можно быстро присваивать переменным большие/длинные значения: 

| Объект | Описание |
|----------|----------|
| <img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/spaceship.gif?raw=true" width="225">   |**объект:** космический корабль <br> **класс корабля:** штурмовой <br> **работает:** да <br> **скорость:** 32000 <br> **количество пушек:** 4|
| <img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/spaceship2.gif?raw=true" width="225">   |**объект:** космический корабль <br> **класс корабля:** разведывательный <br> **работает:** да <br> **скорость:** 48000 <br> **количество пушек:** 0|

Представим в виде функции:
```python
def create_spaceship(object, ship_class, works, speed, guns):
    if works == True:
        return f"[{object}] class: {ship_class} speed: {speed} number of guns: {guns}"
    else:
        return f"[{object}] class: {ship_class} speed: {speed} number of guns: {guns} ERROR: the ship is broken!"

spaceship_1 = create_spaceship("spaceship", "assault", True, 32000, 4)
spaceship_2 = create_spaceship("spaceship", "reconnaissance", True, 48000, 0)
spaceship_3 = create_spaceship("spaceship", "cargo ", False, 13000, 0)

print(spaceship_1)
print(spaceship_2)
print(spaceship_3)
```
### Пример 4
Функции можно вызывать в потоке. Есть план для текстовой игры:

![image](https://github.com/user-attachments/assets/1291e97d-40b3-4a91-9a63-317ea1c1d69d)


```python
def start():
    print("Игра началась")

def rules():
    print("Правила игры ...")

def menu():
    while True:
        print("[1] - Начать игру\n[2] - Правила игры\n[3] - Выход")
        answer = input("> ")
        if answer == "1":
            start()
            break
        elif answer == "2":
            rules()
        elif answer == "3":
            print("Выход...")
            break
        else:
            print("Такого варианта нет. Повторите выбор.")


menu()
```

## Аргументы функций

<img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/Animais.gif?raw=true">

Аргументов (параметров) для функции бывает несколько. Различные типы аргументов в функции с реальным кодом.

Есть функция, которая приветствует пользователей и проверяет их возраст. Если пользователю меньше 16 лет, то ему отказано в доступе, иначе разрешено. На данной функции будут рассмотрены первые 3 примера.
Протестируйте программу и вызов функции с разными аргументами.
```python
def user_verification(name_user, age_user):
    print(f"Hello {name_user}! You are {age_user} years old.")
    
    if age_user < 16:
        print("Sorry, you are denied access.")
    else:
        print("Access granted!")
```

### 1. Позиционные аргументы
Передаются в функцию в определенном порядке.
```python
user_verification("Ruby", 28)
user_verification("Melissa", 15)
```

### 2. Именованные аргументы
Позволяют явно указывать имена параметров при вызове функции.
```python
user_verification(age_user=14, name_user="Ruby")
user_verification(name_user="Melissa", age_user=36)
```

### 3. Аргументы со значениями по умолчанию
Параметры могут иметь значения по умолчанию, которые используются, если аргумент не был передан. Параметры со значениями по умолчанию должны идти после обычных параметров.

Для этого примера, мы немного поменяем программу, добавив ей третий аргумент и немного дополним структуру самой функции:
```python
def user_verification(name_user, age_user, gender_user=None):
    if gender_user == None:
        print(f"Hello, {name_user}! You are {age_user} years old.")
    else:
        print(f"Hello, {name_user}! You are {age_user} years old. Gender: {gender_user}")
    
    if age_user < 16:
        approved = True
        print("Sorry, you are denied access.")
    else:
        print("Access granted!")

user_verification("Judy", 26, "female")
user_verification("Tom", 11, "male")
user_verification("Henry", 22)
```
Такой вариант добавляет возможность выбора для пользователя и исключению ошибок, если вдруг аргумент не был заполнен. Может иметь любое начальное значение с любым типом данных.

### 4. Неопределенное количество позиционных аргументов (`*args`)
Позволяет функции принимать любое количество позиционных аргументов. Аргументы передаются как кортеж.

```python
def add_numbers(*args):
    total = 0
    for number in args:
        total += number
    return total

# Вызов функции с разным количеством аргументов
print(add_numbers(1, 2, 3))        # Выведет: 6
print(add_numbers(5, 10, 15, 20))  # Выведет: 50
```
Или:
```python
def summ(*args):
    res = sum(args)
    print(f"Сумма: {res}")

# Вызов функции с несколькими аргументами
summ(1, 2, 3, 4)
```
### 5. Неопределенное количество именованных аргументов (`**kwargs`)
Позволяет функции принимать любое количество именованных аргументов. Они передаются в функцию в виде словаря, что позволяет обрабатывать их по ключу.
```python
def user_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

# Вызов функции с разными именованными аргументами
user_info(name="Alice", age=30, gender="female")
# Выведет:
# name: Alice
# age: 30
# gender: female

user_info(name="Bob", occupation="Engineer", country="USA")
# Выведет:
# name: Bob
# occupation: Engineer
# country: USA
```

### 6. Комбинация различных типов аргументов
Можно комбинировать позиционные, `*args`, аргументы со значениями по умолчанию, `**kwargs`.
```python
def complex_function(a, b=2, *args, **kwargs):
    print(f"a: {a}, b: {b}")
    print(f"Дополнительные позиционные аргументы: {args}")
    print(f"f"Именованные аргументы: {kwargs}")

# Вызов функции с приведенными аргументами
complex_function(1, 3, 4, 5, x=10, y=20)
```

## Глобальные и локальные переменные

<img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/snow.gif?raw=true">

Так как мы подошли к теме функций, вы могли заметить, что Python не будет выдавать ошибку при использовании переменных с одинаковыми именами вне и внутри функции. Например:
```python
var = 15

def summ(a, b):
    var = a + b
    return var

print(var)
print(summ(2, 3))
```
Конечно, так лучше вообще не делать, но код работает. Такое происходит, потому что var на первой строке — глобальная переменная, а var внутри функции — локальная переменная.
<br><br>
В Python переменные могут быть локальными или глобальными, и их область видимости (scope) определяет, где они могут быть использованы в коде.

### Глобальные переменные
Переменные, объявленные вне всех функций и доступны для использования в любой части кода, включая функции.

Они доступны для чтения и изменения (если использовать global) внутри функций.

Пример использования:
```python
count = 0  # Глобальная переменная

def increment():
    global count  # Используем глобальную переменную
    count += 1

increment()
print(count)  # Выведет: 1
```
**Важно!** Если вы хотите изменить глобальную переменную внутри функции, нужно явно указать global, чтобы сказать Python, что вы ссылаетесь на глобальную переменную, а не создаете новую локальную.

### Локальные переменные
Определение: Переменные, объявленные внутри функции и доступны только в пределах этой функции.

Они существуют только во время выполнения функции и недоступны за ее пределами.

Пример использования:
```python
def my_function():
    local_var = 10  # Локальная переменная
    print(local_var)

my_function()  # Выведет: 10
print(local_var)  # Ошибка: 'local_var' не доступна вне функции
```
**Важно!** Локальные переменные создаются и уничтожаются каждый раз при вызове функции, поэтому они не сохраняют значения между вызовами.

### Ещё о локальных переменных
Бывает такое, что функции вложены. Чтобы изменить переменную из одной функции в другой, используют ключевое слово `nonlocal`. Оно позволяет обращаться к переменной из объемлющей функции и изменять ее значение внутри вложенной функции.
Пример с использованием:
```python
def outer_function():
    x = 10  # Переменная в объемлющей функции

    def inner_function():
        nonlocal x  # Указываем, что x - переменная из объемлющей области
        x += 5
        print(f"Внутри inner_function: {x}")  # Выведет: 15

    inner_function()
    print(f"Внутри outer_function: {x}")  # Выведет: 15

outer_function()
```
Пояснение:
* В функции `outer_function` создается переменная `x` со значением 10.
* Внутри `outer_function` определена `inner_function`, которая использует `nonlocal` для изменения переменной `x` из объемлющей области.
* При вызове `inner_function` переменная x увеличивается на 5.
* После этого изменения видны и в `inner_function`, и в `outer_function`.

## Частые ошибки

| 🏡 | Список ошибок |
|----------|----------|
| <img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/sv.gif?raw=true">   |1. Передача недостаточного или избыточного количества аргументов при вызове функции. <br> 2. Изменение глобальных переменных внутри функции. <br> 3. Забыта инструкция return, или она не используется, когда нужно вернуть значение. В результате функция возвращает None. <br> 4. Неправильное управление изменяемыми объектами, такими как списки или словари, может привести к неожиданным результатам, так как они передаются по ссылке. <br> 5. Использование одинаковых имен для параметров функции и глобальных переменных может привести к путанице и ошибкам. <br> 6. Неправильное позиционирование или использование `*args` и `**kwargs` в определении функции может вызвать ошибки. <br> 7. Использование изменяемых объектов в качестве значений по умолчанию может привести к неожиданным результатам, поскольку они создаются только один раз при определении функции. <br> 8. Отсутствие документации в функциях затрудняет понимание их назначения и использования.|

## Задания для самостоятельного выполнения

<img src="https://github.com/TeachKait20/NoneCode/blob/main/func+python/hack.gif?raw=true" width="350">

### Задание 1
Задание разбито на части. Не переходите к другой части, пока не выполнена предыдущая.

**Часть 1**

* Создайте функцию, принимающую на вход три аргумента как три стороны треугольника. В зависимости от переданных сторон выведите сообщение пользователю: "Равносторонний треугольник", "Равнобедренный треугольник" или "Разносторонний треугольник". Если по переданным сторонам треугольник построить невозможно, выведете: "Некорректные стороны. Невозможно построить треугольник." Чтобы определить, можно ли построить треугольник с заданными сторонами, нужно проверить, что сумма любых двух сторон больше третьей.
  
  ![image](https://github.com/user-attachments/assets/2188c7b8-4673-42ca-8d5e-1057a73109e7)

* Постарайтесь сделать оформление для выходных данных максимально приближено к примеру.

**Пример входных данных:** <br>
![image](https://github.com/user-attachments/assets/9573b1b2-8f4d-4143-abaf-c835c24aa24d)

**Пример выходных данных:** <br>
![image](https://github.com/user-attachments/assets/0cf3256b-0830-4051-81d0-4484f16122ee)

**Часть 2**

* Дополним информацию о треугольнике, выведем его периметр и площадь.
* После всех проверок, добавьте расчёт для вычисления периметра и площади. Периметром треугольника называют сумму длин трёх его сторон, а половину этой величины называют полупериметром. В данном случае, лучше всего подойдёт формула Герона:
  
![image](https://github.com/user-attachments/assets/466a4863-5759-4455-b61d-03254cc5efe1)

* Найдите способ оставить только 2 знака после точки.

Описание: 
* В коде найдите периметр: `p = a + b + c`
* Далее полупериметр: `s = p / 2`
* И наконец площадь: `area = (s * (s - a) * (s - b) * (s - c)) ** 0.5`

В Python нет прямого обозначения корня, поэтому воспользуемся `** 0.5`

**Пример входных данных:** <br>
![image](https://github.com/user-attachments/assets/ef0e24a5-65ce-41f2-8ebd-ab0db4c6a0b1)

**Пример выходных данных:** <br>
![image](https://github.com/user-attachments/assets/bb505c08-d4ef-4b8a-9c78-d3ccaaec8dec)

### Задание 2
